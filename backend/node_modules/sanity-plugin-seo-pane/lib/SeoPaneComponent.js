"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = SeoPaneComponent;

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _ui = require("@sanity/ui");

var _reactQuery = require("react-query");

var _get = _interopRequireDefault(require("lodash/get"));

var _asyncCall = _interopRequireDefault(require("./lib/asyncCall"));

var _performSeoReview = _interopRequireDefault(require("./lib/performSeoReview"));

var _renderRatingToColor = require("./lib/renderRatingToColor");

var _resultsLabels = require("./lib/resultsLabels");

var _ErrorStack = _interopRequireDefault(require("./ErrorStack.js"));

var _SerpPreview = _interopRequireDefault(require("./SerpPreview.js"));

var _Feedback = _interopRequireDefault(require("./Feedback"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function SeoPaneComponent(_ref) {
  var _meta$description;

  var sanityDocument = _ref.document,
      options = _ref.options;

  var _useState = (0, _react.useState)(''),
      _useState2 = _slicedToArray(_useState, 2),
      tab = _useState2[0],
      setTab = _useState2[1]; // The `revision` key updates when the document does, refreshing the query


  var _useQuery = (0, _reactQuery.useQuery)(["seoReview", sanityDocument._rev], /*#__PURE__*/_asyncToGenerator(function* () {
    if (!sanityDocument._id) throw new Error('Document is not published');else if (!options.url) badOption('url');

    var _yield$Promise$all = yield Promise.all([(0, _asyncCall.default)(options.keywords, sanityDocument), (0, _asyncCall.default)(options.synonyms, sanityDocument), (0, _asyncCall.default)(options.url, sanityDocument)]),
        _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 3),
        keywords = _yield$Promise$all2[0],
        synonyms = _yield$Promise$all2[1],
        url = _yield$Promise$all2[2]; // Visits document path when strings because the asyncCall will have same value as options


    if (keywords && keywords === options.keywords) keywords = (0, _get.default)(sanityDocument, keywords);
    if (synonyms && synonyms === options.synonyms) synonyms = (0, _get.default)(sanityDocument, synonyms); // Tack on keywords and synonyms to seo review response since we use them.

    return _objectSpread(_objectSpread({}, yield (0, _performSeoReview.default)(url, keywords, synonyms)), {}, {
      keywords,
      synonyms
    });
  }), {
    keepPreviousData: true
  }),
      data = _useQuery.data,
      isLoading = _useQuery.isLoading,
      error = _useQuery.error; // Will only show on the first render because of `keepPreviousData` above


  if (isLoading) {
    return /*#__PURE__*/_react.default.createElement(_ui.Flex, {
      align: "center",
      justify: "center",
      padding: 4
    }, /*#__PURE__*/_react.default.createElement(_ui.Spinner, {
      muted: true
    }));
  } // Bail out on error. Unfortunately can't JSON.stringify(Error) to get the stack/message.


  var errorMessage;

  if (error instanceof Error) {
    errorMessage = /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, error.message, " ", /*#__PURE__*/_react.default.createElement(_ErrorStack.default, {
      stack: error.stack
    }));
  } else if (!data) errorMessage = 'Empty response';else if (data.error) errorMessage = /*#__PURE__*/_react.default.createElement("pre", null, JSON.stringify(data.error));

  if (errorMessage) {
    return /*#__PURE__*/_react.default.createElement(_Feedback.default, {
      isError: true
    }, "Error: ", errorMessage);
  }

  var keywords = data.keywords,
      meta = data.meta,
      permalink = data.permalink,
      resultsMapped = data.resultsMapped,
      synonyms = data.synonyms;
  return /*#__PURE__*/_react.default.createElement(_ui.Box, {
    padding: 4
  }, /*#__PURE__*/_react.default.createElement(_ui.Flex, {
    direction: "column"
  }, (meta === null || meta === void 0 ? void 0 : meta.title) && /*#__PURE__*/_react.default.createElement(_ui.Card, {
    border: true,
    padding: 4,
    radius: 2
  }, /*#__PURE__*/_react.default.createElement(_SerpPreview.default, {
    title: meta === null || meta === void 0 ? void 0 : meta.title,
    metaDescription: (_meta$description = meta === null || meta === void 0 ? void 0 : meta.description) !== null && _meta$description !== void 0 ? _meta$description : "",
    url: permalink
  })), /*#__PURE__*/_react.default.createElement(_ui.Flex, {
    paddingY: 4
  }, /*#__PURE__*/_react.default.createElement(_ui.Stack, {
    space: 3
  }, /*#__PURE__*/_react.default.createElement(_ui.Label, {
    muted: true,
    size: 1
  }, "Keywords"), /*#__PURE__*/_react.default.createElement(_ui.Text, {
    size: 2
  }, keywords ? "\"".concat(keywords, "\"") : "Not Defined")), /*#__PURE__*/_react.default.createElement(_ui.Stack, {
    space: 3,
    marginLeft: 6
  }, /*#__PURE__*/_react.default.createElement(_ui.Label, {
    muted: true,
    size: 1
  }, "Synonyms"), /*#__PURE__*/_react.default.createElement(_ui.Text, {
    size: 2
  }, synonyms ? "\"".concat(synonyms, "\"") : "Not Defined"))), /*#__PURE__*/_react.default.createElement(_ui.TabList, {
    space: 1
  }, Object.keys(resultsMapped).map((key, tabIndex) => /*#__PURE__*/_react.default.createElement(_ui.Tab, {
    "aria-controls": key,
    key: "".concat(key, "-button"),
    id: "".concat(key, "-button"),
    label: "".concat(resultsMapped[key].length, " ").concat(resultsMapped[key].length === 1 ? _resultsLabels.resultsLabels[key].single : _resultsLabels.resultsLabels[key].plural) // eslint-disable-next-line react/jsx-no-bind
    ,
    onClick: () => setTab(key),
    selected: tab === key || !tab && !tabIndex,
    space: 2
  }))), Object.keys(resultsMapped).map((key, panelIndex) => /*#__PURE__*/_react.default.createElement(_ui.TabPanel, {
    "aria-labelledby": key,
    hidden: tab && tab !== key || !tab && panelIndex,
    key: "".concat(key, "-panel"),
    id: "".concat(key, "-panel"),
    style: {
      margin: "0.5rem 0",
      padding: "0.5rem 0"
    }
  }, resultsMapped[key].map((result, resultIndex) => /*#__PURE__*/_react.default.createElement(_ui.Flex, {
    key: "result-".concat(resultIndex),
    alignItems: "center",
    style: {
      margin: "0.5rem 0"
    }
  }, /*#__PURE__*/_react.default.createElement("div", {
    style: {
      borderRadius: 10,
      width: 10,
      height: 10,
      backgroundColor: (0, _renderRatingToColor.renderRatingToColor)(result.rating),
      marginRight: 10,
      flexShrink: 0,
      transform: "translateY(6px)"
    }
  }), (result === null || result === void 0 ? void 0 : result.text) && /*#__PURE__*/_react.default.createElement("div", {
    dangerouslySetInnerHTML: {
      __html: result.text
    }
  })))))));
}

SeoPaneComponent.propTypes = {
  document: _propTypes.default.shape({
    displayed: _propTypes.default.shape({
      _id: _propTypes.default.string,
      _rev: _propTypes.default.string
    })
  }).isRequired,
  options: _propTypes.default.shape({
    keywords: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.func]).isRequired,
    synonyms: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.func]),
    url: _propTypes.default.func.isRequired
  }).isRequired
};

function badOption(key) {
  throw new Error("seo-pane options: ".concat(key, " is invalid or missing"));
}
//# sourceMappingURL=SeoPaneComponent.js.map